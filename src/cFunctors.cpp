//
// Created by brainslush on 19.06.17.
//

#include "cFunctors.h"

using namespace functor;

filamentCollision::filamentCollision(mygui::gui *&iGui) :
        guiGroup(iGui->register_group("Collision")),
        activated(guiGroup->register_setting<bool>("Active", true, true)) {

}

functor::filamentCollision::~filamentCollision() {

}

std::pair<Eigen::Vector3d, Eigen::Vector3d>
functor::filamentCollision::calc(
        Eigen::Vector3d &X,
        Eigen::Vector3d &v,
        Eigen::Quaterniond &R,
        Eigen::Vector3d &L
) {
    if (activated) {
        return std::make_pair(Eigen::Vector3d(0, 0, 0), Eigen::Vector3d(0, 0, 0));
    }
    return std::make_pair(Eigen::Vector3d(0, 0, 0), Eigen::Vector3d(0, 0, 0));
}

dampening::dampening(mygui::gui *&iGui) :
        guiGroup(iGui->register_group("Dampening")),
        activated(guiGroup->register_setting<bool>("Active", true, true)) {

}

dampening::~dampening() {

}

std::pair<Eigen::Vector3d, Eigen::Vector3d>
dampening::calc(
        Eigen::Vector3d &X,
        Eigen::Vector3d &v,
        Eigen::Quaterniond &R,
        Eigen::Vector3d &L
) {
    return std::make_pair(Eigen::Vector3d(0, 0, 0), Eigen::Vector3d(0, 0, 0));
}


membraneSpring::membraneSpring(mygui::gui *&iGui) :
        guiGroup(iGui->register_group("Spring Force")),
        activated(guiGroup->register_setting<bool>("Active", true, true)),
        kStretch(guiGroup->register_setting<double>("kStretch", true, 0, 1, 0.1)),
        kBend(guiGroup->register_setting<double>("kBend",true, 0, 1, 0.1))
{

}

membraneSpring::~membraneSpring() {

}

std::pair<Eigen::Vector3d, Eigen::Vector3d>
membraneSpring::calc(
        Eigen::Vector3d &X,
        Eigen::Vector3d &v,
        Eigen::Quaterniond &R,
        Eigen::Vector3d &L,
        membrane_part_base *membrane
) {
    // acquire some data
    std::pair<membrane_part_base *, membrane_part_base *> &neighbours = membrane->get_neighbours();
    std::pair<Eigen::Vector3d *, Eigen::Vector3d *> &sharedPositions = membrane->get_sharedPositions();
    double length = membrane->get_length();
    // calculate the normalized direction vector of the membrane element
    Eigen::Vector3d dirVector = membrane->calc_dirVector(&membrane->get_positions()[1]);
    // calculate the normalized direction vectors of the neighbouring membrane elements
    Eigen::Vector3d springForceNeighA = neighbours.first->calc_dirVector(sharedPositions.first);
    Eigen::Vector3d springForceNeighB = neighbours.second->calc_dirVector(sharedPositions.second);
    // calculate the torsion force between the membrane and the neighbours
    Eigen::Vector3d springTorqueNeighA = kBend * springForceNeighA.cross(dirVector);
    Eigen::Vector3d springTorqueNeighB = kBend * springForceNeighB.cross(-dirVector);
    // calculate the stretching force generated by the neighbouring membrane elements
    springForceNeighA *= -kStretch * (neighbours.first->get_restLength() - neighbours.first->get_length());
    springForceNeighB *= -kStretch * (neighbours.second->get_restLength() - neighbours.second->get_length());
    // calculate torque due to stretching above
    Eigen::Vector3d stretchTorqueNeighA = (0.5 * length) * springForceNeighA.cross(dirVector);
    Eigen::Vector3d stretchTorqueNeighB = (0.5 * length) * springForceNeighB.cross(-dirVector);
    // set velocity and angular momentum to zero for complete overdampining
    v = Eigen::Vector3d(0, 0, 0);
    L = Eigen::Vector3d(0, 0, 0);

    return {
            springForceNeighA + springForceNeighB,
            springTorqueNeighA + springTorqueNeighB + stretchTorqueNeighA + stretchTorqueNeighB
    };
}


