//
// Created by brainslush on 19.06.17.
//

#include "cFunctors.h"

using namespace functor;

filamentCollision::filamentCollision(mygui::group *&iGroup) :
        activated(iGroup->register_setting<bool>("Active", true, true)) {

}

functor::filamentCollision::~filamentCollision() {

}

std::pair<Eigen::Vector3d, Eigen::Vector3d>
functor::filamentCollision::calc(
        const Eigen::Vector3d &X,
        const Eigen::Vector3d &v,
        const Eigen::Quaterniond &R,
        const Eigen::Vector3d &L
) {
    if (activated) {
        return std::make_pair(Eigen::Vector3d(0, 0, 0), Eigen::Vector3d(0, 0, 0));
    }
    return std::make_pair(Eigen::Vector3d(0, 0, 0), Eigen::Vector3d(0, 0, 0));
}

dampening::dampening(mygui::group *&iGroup) :
        activated(iGroup->register_setting<bool>("Active", true, true)) {

}

dampening::~dampening() {

}

std::pair<Eigen::Vector3d, Eigen::Vector3d>
dampening::calc(
        const Eigen::Vector3d &X,
        const Eigen::Vector3d &v,
        const Eigen::Quaterniond &R,
        const Eigen::Vector3d &L
) {
    return std::make_pair(Eigen::Vector3d(0, 0, 0), Eigen::Vector3d(0, 0, 0));
}


membraneSpring::membraneSpring(mygui::group *&iGroup) :
        activated(iGroup->register_setting<bool>("Active", true, true)) {

}

membraneSpring::~membraneSpring() {

}

std::pair<Eigen::Vector3d, Eigen::Vector3d>
membraneSpring::calc(
        const Eigen::Vector3d &X,
        const Eigen::Vector3d &v,
        const Eigen::Quaterniond &R,
        const Eigen::Vector3d &L,
        membrane_part_base *membrane
) {
    // acquire some data
    std::pair<membrane_part_base &, membrane_part_base &> &neighbours = membrane->get_neighbours();
    std::pair<Eigen::Vector3d &, Eigen::Vector3d &> &sharedPositions = membrane->get_sharedPositions();

    // calculate the normalized direction vector of the membrane element
    Eigen::Vector3d dirVector = membrane->calc_dirVector(membrane->get_positions()[1]);
    // calculate the normalized direction vectors of the neighbouring membrane elements
    Eigen::Vector3d springForceNeighA = neighbours.first.calc_dirVector(sharedPositions.first);
    Eigen::Vector3d springForceNeighB = neighbours.second.calc_dirVector(sharedPositions.second);
    // calculate the torsion force between the membrane and the neighbours
    Eigen::Vector3d springTorqueNeighA = kBend * springForceNeighA.cross(dirVector);
    Eigen::Vector3d springTorqueNeighB = kBend * springForceNeighB.cross(-dirVector);
    // calculate the stretching force generated by the neighbouring membrane elements
    springForceNeighA *= -kStretch * (neighbours.first.get_restLength() - neighbours.first.get_length());
    springForceNeighB *= -kStretch * (neighbours.second.get_restLength() - neighbours.second.get_length());
    // calculate torque due to stretching above



    return pair<Eigen::Vector3d, Eigen::Vector3d>();
}


